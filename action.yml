name: 'PSE Security Proxy'
description: 'Sets up PSE Security Proxy for secure package downloads'
author: 'InvisiRisk'
branding:
  icon: 'shield'
  color: 'blue'

inputs:
  api_url:
    description: 'URL of the InvisiRisk API (required for setup, optional for cleanup)'
    required: false
  app_token:
    description: 'Authentication token for the InvisiRisk API (required for setup, optional for cleanup)'
    required: false
  portal_url:
    description: 'URL of the InvisiRisk Portal (defaults to api_url if not provided)'
    required: false
    default: ''
  github_token:
    description: 'GitHub token to be passed to the PSE container for GitHub authentication'
    required: false
    default: ${{ github.token }}
  debug:
    description: 'Enable debug mode for verbose logging'
    required: false
    default: 'false'
  test_mode:
    description: 'Enable test mode to bypass API calls and container setup for testing. Use this when you want to test the action without actually running the PSE container.'
    required: false
    default: 'false'
  cleanup:
    description: 'Set to true to run cleanup instead of setup. This should be used at the end of your workflow.'
    required: false
    default: 'false'
  scan_id:
    description: 'Scan ID from the setup step. Optional even for cleanup - if not provided, a default value will be used.'
    required: false
    default: ''

runs:
  using: "composite"
  steps:
    - name: Run Setup or Cleanup
      shell: bash
      run: |
        # Check if running inside a container
        IS_CONTAINER="false"
        
        # Method 1: Check for .dockerenv file
        if [ -f "/.dockerenv" ]; then
          IS_CONTAINER="true"
          echo "Detected container environment via /.dockerenv"
        fi
        
        # Method 2: Check cgroup
        if [ "$IS_CONTAINER" = "false" ] && grep -q docker /proc/1/cgroup 2>/dev/null; then
          IS_CONTAINER="true"
          echo "Detected container environment via cgroup"
        fi
        
        # Method 3: Check for container-specific environment variables
        if [ "$IS_CONTAINER" = "false" ] && [ -n "$KUBERNETES_SERVICE_HOST" ]; then
          IS_CONTAINER="true"
          echo "Detected container environment via Kubernetes environment variables"
        fi
        
        # Set the environment variable
        echo "RUNNING_IN_CONTAINER=$IS_CONTAINER" >> $GITHUB_ENV
        echo "Running in container: $IS_CONTAINER"
        
        # Debug mode: List files and environment variables if running in container
        if [ "$IS_CONTAINER" = "true" ] && [ "${{ inputs.debug }}" = "true" ]; then
          echo "Debug mode enabled in container environment. Listing files and directories:"
          
          # Check if tree command is available, install if not
          if ! command -v tree &> /dev/null; then
            echo "Installing tree command..."
            apt-get update -qq && apt-get install -y tree || {
              echo "Could not install tree, falling back to find command"
            }
          fi
          
          # Try tree command first, fallback to find if not available
          if command -v tree &> /dev/null; then
            echo "Directory structure (using tree):"
            tree -a -L 3 "$GITHUB_WORKSPACE" || echo "Tree command failed"
          else
            echo "Directory structure (using find):"
            find "$GITHUB_WORKSPACE" -type f -o -type d | sort
          fi
          
          # Print all environment variables
          echo ""
          echo "Environment variables:"
          echo "==================="
          # Print all environment variables but mask sensitive ones
          env | sort | sed 's/\(.*TOKEN.*=\).*/\1********/g' | sed 's/\(.*SECRET.*=\).*/\1********/g' | sed 's/\(.*PASSWORD.*=\).*/\1********/g' | sed 's/\(.*KEY.*=\).*/\1********/g'
        fi
        
        # Store API credentials for both setup and cleanup
        if [ "${{ inputs.cleanup }}" != "true" ]; then
          # Only store these during setup phase
          echo "PSE_API_URL=${{ inputs.api_url }}" >> $GITHUB_ENV
          echo "PSE_APP_TOKEN=${{ inputs.app_token }}" >> $GITHUB_ENV
          echo "PSE_PORTAL_URL=${{ inputs.portal_url || inputs.api_url }}" >> $GITHUB_ENV
        fi

        if [ "${{ inputs.cleanup }}" = "true" ]; then
          echo "Running PSE cleanup..."
          chmod +x ${{ github.action_path }}/cleanup.sh
          ${{ github.action_path }}/cleanup.sh
        else
          echo "Running PSE setup..."
          
          # First create scan in InvisiRisk Portal
          echo "Creating scan in InvisiRisk Portal..."
          
          # Create the scan directly in action.yml
          SCAN_RESPONSE=$(curl -L -s -X POST "${{ inputs.api_url }}/utilityapi/v1/scan" \
            -H "Content-Type: application/json" \
            -d "{\"api_key\": \"${{ inputs.app_token }}\"}")
          
          # Extract scan ID using grep
          SCAN_ID=$(echo "$SCAN_RESPONSE" | grep -o '"scan_id":"[^"]*"' | cut -d'"' -f4)
          
          # If first pattern fails, try alternative field name
          if [ -z "$SCAN_ID" ]; then
            SCAN_ID=$(echo "$SCAN_RESPONSE" | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
          fi
          
          # If still not found, try to extract from data field
          if [ -z "$SCAN_ID" ]; then
            # Try to extract from data.scan_id
            SCAN_ID=$(echo "$SCAN_RESPONSE" | grep -o '"data":{[^}]*"scan_id":"[^"]*"' | grep -o '"scan_id":"[^"]*"' | cut -d'"' -f4)
          fi
          
          # Try one more pattern
          if [ -z "$SCAN_ID" ]; then
            # Try to extract from data.id
            SCAN_ID=$(echo "$SCAN_RESPONSE" | grep -o '"data":{[^}]*"id":"[^"]*"' | grep -o '"id":"[^"]*"' | cut -d'"' -f4)
          fi
          
          if [ -z "$SCAN_ID" ]; then
            echo "Error: Failed to extract scan ID from response"
            exit 1
          fi
          
          echo "Scan created with ID: $SCAN_ID"
          echo "SCAN_ID=$SCAN_ID" >> $GITHUB_ENV
          echo "scan_id=$SCAN_ID" >> $GITHUB_OUTPUT
          
          # Run setup script - use environment variables for more reliable paths
          echo "Using action path: $GITHUB_ACTION_PATH"
          
          # Try multiple possible paths for the setup script
          if [ -f "$GITHUB_ACTION_PATH/setup.sh" ]; then
            echo "Found setup.sh at GITHUB_ACTION_PATH"
            chmod +x "$GITHUB_ACTION_PATH/setup.sh"
            "$GITHUB_ACTION_PATH/setup.sh"
          elif [ -f "${{ github.action_path }}/setup.sh" ]; then
            echo "Found setup.sh at github.action_path"
            chmod +x "${{ github.action_path }}/setup.sh"
            "${{ github.action_path }}/setup.sh"
          else
            echo "ERROR: Could not find setup.sh in any of the expected locations"
            echo "Searched in:"
            echo "  - $GITHUB_ACTION_PATH/setup.sh"
            echo "  - ${{ github.action_path }}/setup.sh"
            
            # List files in potential directories to help debug
            echo ""
            echo "Listing files in GITHUB_ACTION_PATH (if it exists):"
            if [ -d "$GITHUB_ACTION_PATH" ]; then
              ls -la "$GITHUB_ACTION_PATH"
            else
              echo "GITHUB_ACTION_PATH directory does not exist"
            fi
            
            echo ""
            echo "Listing files in github.action_path (if it exists):"
            if [ -d "${{ github.action_path }}" ]; then
              ls -la "${{ github.action_path }}"
            else
              echo "github.action_path directory does not exist"
            fi
            
            exit 1
          fi
        fi
      env:
        API_URL: ${{ inputs.api_url }}
        APP_TOKEN: ${{ inputs.app_token }}
        PORTAL_URL: ${{ inputs.portal_url || inputs.api_url }}
        SCAN_ID: ${{ inputs.scan_id }}
        DEBUG: ${{ inputs.debug }}
        TEST_MODE: ${{ inputs.test_mode }}
        GITHUB_TOKEN: ${{ inputs.github_token || github.token }}

